<think>
Okay, I need to create Pydantic models for a FastAPI task manager app. Let me think about the requirements. The API has endpoints for listing, creating, retrieving, updating, and deleting tasks. Each task has id, title, description, and completed status.

First, I should define the Pydantic models. The request models will handle the data sent by the client. For the GET /tasks and GET /tasks/{id}, the response models should include all fields. But when creating or updating, the client might not provide the id, so the request model for POST and PUT should exclude the id. Also, the completed field is a boolean, so I need to make sure that's correctly typed.

Wait, the task has an id, which is probably generated by the backend. So when creating a task via POST, the client doesn't include the id. The request model for creating a task should have title, description, and completed. The response model for creation should include the generated id. Similarly, for updating, the client might send some fields, but the id is required in the URL, so the request model for PUT might not need the id. But the PUT request might include all fields, so maybe the request model for PUT includes all fields except id, since the id is part of the URL.

Wait, the PUT endpoint is for updating a task. The client would send the updated data, which could include any of the fields. So the request model for PUT should have title, description, completed, but not the id. Because the id is part of the URL, not the request body.

So, the models would be:

- TaskCreate: includes title, description, completed (optional? Or required? The problem says each task has these fields, so maybe completed is required. But maybe the client can omit it, and the backend sets it to False by default. Wait, the problem says each task has these fields, so perhaps all are required. Wait, the problem says "Each task has: id, title, description, completed (boolean)". So all fields are required. But when creating, the client might not provide the id. So the TaskCreate model would have title, description, completed. The Task model would include id, title, description, completed. The TaskResponse would include all fields, including id.

Wait, but when creating, the id is generated by the backend. So the request model for creating a task (TaskCreate) would not have an id. The response model (TaskResponse) would include the id. Similarly, for updating, the request model (TaskUpdate) would have title, description, completed, but the id is not part of the request body since it's in the URL. However, the problem says that the PUT endpoint is for updating, so the client might send some or all of the fields. So the TaskUpdate model could have optional fields, but the problem says each task has those fields. Wait, maybe the TaskCreate and TaskUpdate models have all the fields except id, and the Task model includes id. But the problem says that each task has those fields, so maybe the Task model includes all, and the request models for create and update have the same fields except id.

Wait, perhaps the TaskCreate model has title, description, completed. The Task model includes id, title, description, completed. The TaskResponse would be the same as the Task model. For the PUT request, the client can send any of the fields, so the TaskUpdate model could have optional fields. But the problem says that each task has those fields, so maybe the PUT request requires all fields? Or maybe the client can send a subset. The problem statement isn't clear. But the user says to include data validation, so perhaps the request models for create and update have all the required fields except id. For example, when creating, the client must provide title, description, and completed. When updating, the client can provide any of those fields, but maybe the model should have them as optional. Wait, but the problem says each task has those fields, so maybe the PUT request requires all fields. Hmm, this is a bit ambiguous. Let me check the original problem again.

The problem says: Each task has: id, title, description, completed (boolean). So all fields are present. But when creating, the client provides title, description, and completed. The id is generated. When updating, the client can provide any of the fields, but the id is not part of the request body. So the request model for PUT should have title, description, completed, but they are optional? Or required? Well, the problem says that the task has those fields, but when updating, the client may not provide all. So the request model for PUT should have optional fields. But the user might expect that all fields are required. Hmm. Maybe the TaskCreate and TaskUpdate models have all the fields except id, and they are required. But that would mean that when updating, the client must provide all fields, which might not be desired. Alternatively, the TaskUpdate model could have optional fields. But the problem says to include data validation, so perhaps the models should have the required fields. But I'm not sure. Let me think again.

The user says to include data validation. So for the POST /tasks, the client must provide title, description, and completed. For the PUT /tasks/{id}, the client can send any of the fields, but the model should validate that. So perhaps the TaskCreate model has title, description, completed (required), and the TaskUpdate model has title, description, completed (optional). But how to represent that in Pydantic. For example, in the TaskCreate model, all fields are required. For the TaskUpdate model, the fields are optional. But the problem says that each task has those fields, so maybe the PUT request requires all fields. But that's not typical. Usually, when updating, you can send a subset of fields. So perhaps the TaskUpdate model has optional fields. But the problem says that each task has those fields, so maybe the PUT request must include all fields. Hmm. This is a bit unclear. Let me check the original problem again.

The problem says: Each task has: id, title, description, completed (boolean). So the task must have all those fields. But when creating, the client provides title, description, and completed. The id is generated. When updating, the client can provide any of the fields, but the id is not part of the request body. So the request model for PUT should have title, description, completed, but they are optional. So the TaskUpdate model would have optional fields. However, the problem says to include data validation, so perhaps the models should have the required fields. But I think that for the PUT request, the client can send any subset of the fields. Therefore, the TaskUpdate model should have optional fields. But how to represent that in Pydantic. For example, in the TaskCreate model, all fields are required. For the TaskUpdate model, the fields are optional. But the problem says that each task has those fields, so maybe the PUT request must include all fields. But that's not standard. So perhaps the TaskCreate model has required fields, and the TaskUpdate model has optional fields. But the problem says that each task has those fields, so maybe the PUT request must include all fields. But that's not typical. I think the correct approach is to have the TaskCreate model with required fields, and the TaskUpdate model with optional fields. So the TaskCreate model would have title, description, completed (required), and the TaskUpdate model would have title, description, completed (optional). But the problem says that each task has those fields, so maybe the PUT request must include all fields. But that's not standard. Let me proceed with the assumption that the PUT request can send any subset of the fields, so the TaskUpdate model has optional fields.

So, the models would be:

- TaskCreate: title (str), description (str), completed (bool)
- TaskUpdate: title (Optional[str]), description (Optional[str]), completed (Optional[bool])
- Task: id (int), title (str), description (str), completed (bool)
- TaskResponse: same as Task

Wait, but the Task model would include all fields, including id. The TaskResponse would be the same as the Task model. So when a task is created, the response includes the generated id. For the GET /tasks/{id}, the response is the Task model. For the PUT, the response would be the updated Task model.

But the problem says to include request models and response models. So the request models are for the POST and PUT, and the response models are for all endpoints. So the TaskCreate and TaskUpdate are the request models, and the Task is the response model.

But for the GET /tasks, the response is a list of Task models. So the response models are Task and List[Task].

So, putting it all together:

Import statements: from pydantic import BaseModel, Field, validator, root_validator, BaseModel, Field, Optional
from typing import List, Optional, Dict, Any

Wait, but the user says to include proper imports. So the code should have the necessary imports.

So the code would have:

from pydantic import BaseModel
from typing import List, Optional

Then, the models:

class TaskCreate(BaseModel):
    title: str
    description: str
    completed: bool

class TaskUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    completed: Optional[bool]

class Task(BaseModel):
    id: int
    title: str
    description: str
    completed: bool

But wait, the Task model is used for responses. So when a task is created, the response includes the id. For the GET /tasks/{id}, the response is the Task model. For the PUT, the response is the updated Task model.

But the TaskUpdate model allows optional fields, which is correct for partial updates.

But the problem says that each task has those fields, so maybe the TaskUpdate model should have all fields as required. But that's not typical. So I think the correct approach is to have the TaskCreate model with required fields, and the TaskUpdate model with optional fields.

So the code would be:

from pydantic import BaseModel
from typing import List, Optional

class TaskCreate(BaseModel):
    title: str
    description: str
    completed: bool

class TaskUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    completed: Optional[bool]

class TaskResponse(BaseModel):
    id: int
    title: str
    description: str
    completed: bool

class TasksResponse(BaseModel):
    tasks: List[TaskResponse]

Wait, but the GET /tasks endpoint returns a list of tasks, so the response model for that would be TasksResponse with a list of TaskResponse. But maybe the TasksResponse is not needed, and the response is simply a list of TaskResponse objects. However, for consistency, perhaps it's better to have a model for the list.

But the user says to include response models. So for the GET /tasks, the response is a list of TaskResponse. For the GET /tasks/{id}, the response is a single TaskResponse. For the POST /tasks, the response is a TaskResponse. For the PUT /tasks/{id}, the response is a TaskResponse. For the DELETE, the response could be a simple message, but the problem doesn't specify. However, the user says to include response models, so perhaps the DELETE response is a simple model.

But the problem says to include response models. So for the DELETE, maybe the response is a message, but the user might expect a model. However, the problem doesn't specify, so perhaps the DELETE response is a simple model like:

class DeleteResponse(BaseModel):
    message: str

But the user might not need that. Since the problem says to include response models, but the DELETE endpoint's response is not specified. So perhaps the response models are only for the GET, POST, PUT, and GET by ID. The DELETE response could be a simple model, but maybe the user expects it to be a model. However, the problem says to include response models, so perhaps the DELETE response is a model. But the user might not have specified. Since the problem says to include response models, perhaps the DELETE response is a model. But the problem doesn't specify, so maybe it's better to assume that the response models are for the GET, POST, PUT, and GET by ID. The DELETE response could be a simple model, but perhaps the user expects it to be a model. However, the problem says to include response models, so maybe the DELETE response is a model. But since the problem doesn't specify, perhaps it's better to focus on the other endpoints.

So, the code would have:

from pydantic import BaseModel
from typing import List, Optional

class TaskCreate(BaseModel):
    title: str
    description: str
    completed: bool

class TaskUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    completed: Optional[bool]

class TaskResponse(BaseModel):
    id: int
    title: str
    description: str
    completed: bool

class TasksResponse(BaseModel):
    tasks: List[TaskResponse]

But the TasksResponse is for the GET /tasks endpoint. However, the user might not need that, but it's better to have it.

But the user says to return only the Python code, no explanations. So the code should include all the models.

So the final code would be:

from pydantic import BaseModel
from typing import List, Optional

class TaskCreate(BaseModel):
    title: str
    description: str
    completed: bool

class TaskUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    completed: Optional[bool]

class TaskResponse(BaseModel):
    id: int
    title: str
    description: str
    completed: bool

class TasksResponse(BaseModel):
    tasks: List[TaskResponse]

But wait, the TasksResponse is for the list of tasks. However, the GET /tasks endpoint returns a list of tasks, so the response model would be TasksResponse. But maybe the user expects that the response is a list of TaskResponse objects, not wrapped in another model. However, the problem says to include response models, so perhaps it's better to have the TasksResponse model.

But the user might not need that. However, the problem says to include response models, so including the TasksResponse is acceptable.

So the code would be as above. Now, the user also mentioned data validation. The TaskCreate and TaskUpdate models ensure that the data is validated. For example, the title and description are required in TaskCreate, and optional in TaskUpdate. The completed field is a boolean.

So the code should be as written.
</think>

```python
from pydantic import BaseModel
from typing import List, Optional

class TaskCreate(BaseModel):
    title: str
    description: str
    completed: bool

class TaskUpdate(BaseModel):
    title: Optional[str]
    description: Optional[str]
    completed: Optional[bool]

class TaskResponse(BaseModel):
    id: int
    title: str
    description: str
    completed: bool

class TasksResponse(BaseModel):
    tasks: List[TaskResponse]